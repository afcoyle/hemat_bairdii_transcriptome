"Min_temp_C°", "Max_temp_C°",
Min_salinity_PSU, Max_salinity_PSU))
# We also have separate columns for logger lat/long and capture lat/long. The logger lat/long may be a tad bit more specific, but has a higher likelihood of being dramatically wrong than the capture lat/long, which is taken from the ship's instruments. Since on this survey pots are separated by a few hundred feet at most, we'll just use the capture lat/long
SMI.dat <- select(SMI.dat, -c(Logger_Lat, Logger_Long))
# Our temperature column also has a nonstandard name (contains the degree symbol), so we'll remove that symbol
SMI.dat <- rename(SMI.dat, Avg_temp_C = "Avg_temp_C°")
# Some crabs have a Well value, but no Well_Num. If we look at other samples, it is evident that wells were numbered beginning at A1 and continuing vertically (e.g. A1 = 1, B1 = 2... H1 = 8, A2 = 9). Therefore, we can convert the Well values to give us a Well_Num
# We'll do this inside a for loop
for (i in 1:nrow(SMI.dat)) {
well_val <- SMI.dat$Well[i]
numb <- gsub("[^[:digit:]]", "", well_val)
lett <- gsub("[[:digit:]]", "", well_val)
num <- (as.numeric(numb) - 1) * 8 + match(lett, LETTERS[1:26])
SMI.dat$Well_Num[i] <- num
}
# We now want to pad this well_num value so it always equals two digits
SMI.dat$Well_Num <- str_pad(SMI.dat$Well_Num, 2, pad = 0)
# Create SPNO column. The format for this is generally YYYYPPWW, with PP = plate number, and WW = well number (and YYYY = year). However, this could create overlaps with the regular 2015 EBS survey, so we'll precede this with "SMI_". Some crabs have NAs for plate and well numbers. These will instead be given an SPNO equal to their ADFG_ID preceded by SMI_.
# Create a blank column for SPNO that we'll fill
SMI.dat$SPNO <- rep("blank", times = nrow(SMI.dat))
# Check if any crabs have an NA for plate, but not well numbers, and vice-versa
SMI.dat[is.na(SMI.dat$Tray) & !is.na(SMI.dat$Well_Num), ]
SMI.dat[!is.na(SMI.dat$Tray) & is.na(SMI.dat$Well_Num), ]
# Excellent. We'll assign crabs with NAs for both plate and well numbers an SPNO equal to their ADFG_ID, as described above.
# We'll work on adding the preceding SMI_ later
SMI.dat[is.na(SMI.dat$Tray) & is.na(SMI.dat$Well_Num), ]$SPNO <- SMI.dat[is.na(SMI.dat$Tray) & is.na(SMI.dat$Well_Num), ]$ADFG_ID
# Now assign all other crabs a standard SPNO, as described above
SMI.dat[!is.na(SMI.dat$Tray) & !is.na(SMI.dat$Well_Num), ]$SPNO <- paste0(2015,
SMI.dat[!is.na(SMI.dat$Tray) & !is.na(SMI.dat$Well_Num), ]$Tray,
SMI.dat[!is.na(SMI.dat$Tray) & !is.na(SMI.dat$Well_Num), ]$Well_Num)
# Beautiful! We now want to preface all SPNO values with "SMI_"
SMI.dat$SPNO <- paste0("SMI_", SMI.dat$SPNO)
# Check SPNO values for NAs and duplicates
SMI.dat[is.na(SMI.dat$SPNO), ]
SMI.dat[duplicated(SMI.dat$SPNO), ]
# We still have 6 duplicates. Looking at each, they're ones that were present in both the SMI.selected.dat and SMI.dat tables, meaning they were visually BCS+ crabs that were noted in the survey and then tagged and sent to Kodiak. All data in the SMI.dat rows is present in the SMI.selected.dat rows, except ADFG_ID (conflicts often present), Shell_Condition (not present in the SMI.selected.dat rows). Therefore, we'll note the SC of each crab, remove rows with SC values, and then add the SC to our SMI.selected.dat rows.
# Get vector of all duplicated SPNO values
dups <- SMI.dat[duplicated(SMI.dat$SPNO), ]$SPNO
# Get IDs of all new-shell crab
newbies <- SMI.dat[SMI.dat$SPNO %in% dups & SMI.dat$Shell_Condition == "New", ]$SPNO
# Get IDs of all old-shell crab
oldbies <- SMI.dat[SMI.dat$SPNO %in% dups & SMI.dat$Shell_Condition == "Old", ]$SPNO
# Eliminate duplicate rows that have a value for shell condition.
SMI.dat <- SMI.dat[!(SMI.dat$SPNO %in% dups & !is.na(SMI.dat$Shell_Condition)), ]
# Add SC = New to all SPNOs IDed as new-shell duplicates above
SMI.dat[SMI.dat$SPNO %in% newbies, ]$Shell_Condition <- "New"
# Do the same thing for SPNOs IDed as old-shell duplicates
SMI.dat[SMI.dat$SPNO %in% oldbies, ]$Shell_Condition <- "Old"
# Remove columns that are now unnecessary
# ident_num: = 2015 or NA for all samples. We created this earlier while separating well IDs out
# We'll also create extra columns for Year, Host_OR_Parasite, Host_Tissue, Preservative, Sample_Status, Species_Name
# All these new columns will apply to all samples taken
# Some info comes from protocol in ../data/jensen_archived_samples/jensen_data/Hemato_samples/data_2014-2019/2015_StMatt/2015_ADFG_St._Matthew_BCS_Protocol_Dmitri
SMI.dat$Year <- 2015
SMI.dat$Host_OR_Parasite <- "Host tissue"          # From protocol
SMI.dat$Host_Tissue <- "Blood"                     # That's what hemolymph is called in the main table
SMI.dat$Preservative <- "EtOH 100%"                # From protocol
SMI.dat$Sample_Status <- "Available"               # We know we've got 4 plates according to our plate inventory, assumed all samples are available
SMI.dat$Species_Name <- "Chionoecetes opilio"      # From protocol, all snow crabs sampled
SMI.dat$Specific_Location = "SM"                   # Code for St. Matthew samples
SMI.dat$General_Location = "BS"                    # Code for Bering Sea (all crabs with Specific_Location = SM have a General_Location = BS)
SMI.dat$LME = 1                                    # Also code for Bering Sea
# Rename columns to fit conventions of full.dat table
SMI.dat <- rename(SMI.dat, c(Date = Capture_Date,
StationID = Station,
Latitude = Capture_Lat,
Longitude = Capture_Long,
Size = Carapace_Width,
Chela = Chela_Height,
Plate = Tray,
DNA_Well_No = Well,
VISUAL = Signs_of_BCS,
Depth = Avg_depth_m,
Bottom_Temp = Avg_temp_C,
ReferenceNO = BCS_Tag_Num,
Collection_Comments = Comments,
BCS_PCR_results = PCR_result))
# We will now write our SMI.dat file to a table
write.csv(SMI.dat, file = "../output/jensen_data/cleaned_data/2015_SMI_data_all_cols.csv", row.names = FALSE)
# If we tried to bind now, we'd run into issues with SPNO as a double in full.dat and a character in SMI.dat
# Convert the SPNO column to a character in full.dat to avoid
full.dat$SPNO <- as.character(full.dat$SPNO)
# We run into a similar issue with Sex. In full.dat, they are listed as 1 = Male, 2 = Female, and 3 = Unknown, while in SMI.dat they are M and F
# Convert M to 1 and F to 2 in SMI.dat
SMI.dat[SMI.dat$Sex == "M", ]$Sex <- "1"
SMI.dat[SMI.dat$Sex == "F", ]$Sex <- "2"
SMI.dat$Sex <- as.numeric(SMI.dat$Sex)
# We have the same problem for shell condition. According to the full.dat Access database, 1 = soft, 2 = new, 3 = old, 4 = very old, 5 = graveyard
# A look at the EBS data sheets shows that the same codes were used in the Excel files. Therefore, we'll rename to fit
SMI.dat[SMI.dat$Shell_Condition == "New" & !is.na(SMI.dat$Shell_Condition), ]$Shell_Condition <- "2"
SMI.dat[SMI.dat$Shell_Condition == "New  (close to Old)" & !is.na(SMI.dat$Shell_Condition), ]$Shell_Condition <- "2"
SMI.dat[SMI.dat$Shell_Condition == "Old" & !is.na(SMI.dat$Shell_Condition), ]$Shell_Condition <- "3"
SMI.dat[SMI.dat$Shell_Condition == "Very Old" & !is.na(SMI.dat$Shell_Condition), ]$Shell_Condition <- "4"
# Check to be sure we've fixed all names for shell condition codes
table(SMI.dat$Shell_Condition)
# Change to numeric
SMI.dat$Shell_Condition <- as.numeric(SMI.dat$Shell_Condition)
# Same issue with Reference Number. This one's easier - we'll just change SMI.dat$BCS_Tag_Num (which we just renamed to ReferenceNO) to a character
SMI.dat$ReferenceNO <- as.character(SMI.dat$ReferenceNO)
# Bind rows from SMI dat to combined Access and Excel data
full.dat <- bind_rows(full.dat, SMI.dat)
# We'll also write this to a csv file
write.csv(full.dat, file = "../output/jensen_data/cleaned_data/all_data_all_cols.csv", row.names = FALSE)
View(full.dat)
# Remove all rows without a plate ID
full.plate.dat <- full.dat[!is.na(full.dat$Plate), ]
# Remove all rows with a year prior to 2003
table(full.plate.dat$Year)
# Our previous filter already took care of that! However, some crab are labeled 2109
# A quick visual check confirmed they all have a collection date in 2019. Let's fix:
full.plate.dat$Year <- recode(full.plate.dat$Year, "2109" = 2019)
# We'll also remove all samples listed as discarded
table(full.plate.dat$Sample_Status, useNA = "ifany")
# Remove all listed as "Used Up/Thrown Away" or "Used Up/Thrown Out/unavailable"
full.plate.dat <- full.plate.dat %>%
filter(Sample_Status == "Available" | Sample_Status == "To Roberts lab" | is.na(Sample_Status))
# Get the number of non-NA values per column
sapply(full.plate.dat, function(y) sum(length(which(!is.na(y)))))
full.plate.dat <- select(full.plate.dat, -c(Taxon_Removed, Parasite_Species, Parasite_Most_Recent_ID_By, DISTID, Most_Recent_ID_By))
# Host_OR_Parasite: Check
table(full.plate.dat$Host_OR_Parasite, useNA = "ifany")
# Remove the Host_OR_Parasite column
full.plate.dat <- full.plate.dat %>%
select(-Host_OR_Parasite)
# Host_Tissue: Check
table(full.plate.dat$Host_Tissue, useNA = "ifany")
# Only 3 aren't blood. Add this data to the comments, then remove column
# Sample comments are either blank or "tiny leg in well". Can overwrite.
full.plate.dat[full.plate.dat$Host_Tissue == "Leg", ]$Sample_Comments <- "leg tissue sample taken"
full.plate.dat[full.plate.dat$Host_Tissue == "Muscle", ]$Sample_Comments <- "muscle tissue sample taken"
full.plate.dat <- full.plate.dat %>%
select(-Host_Tissue)
# Sample_Type: Check
table(full.plate.dat$Sample_Type, useNA = "ifany")
# Remove - all are DNA or NA
full.plate.dat <- full.plate.dat %>%
select(-Sample_Type)
# Preservative: Check
table(full.plate.dat$Preservative, useNA = "ifany")
# Protocol: Check
table(full.plate.dat$Protocol, useNA = "ifany")
# Sample_Status: Check
table(full.plate.dat$Sample_Status, useNA = "ifany")
# We already filtered by this one to only include samples we'd presumably have, let's remove
full.plate.dat <- full.plate.dat %>%
select(-Sample_Status)
# Species_Name: Check if we have any NAs, because we can remove those
table(full.plate.dat$Species_Name, useNA = "ifany")
# Sex: Check just for consistent code use. Should have practically all 1s and 2s (M and F, respectively)
table(full.plate.dat$Sex, useNA = "ifany")
# We have 550-ish Code 3s (equal to Sex Unknown), and one NA.
# Change the 3s to NAs (ADFG loves to use numeric codes for NAs)
full.plate.dat <- full.plate.dat %>%
mutate(Sex = na_if(Sex, "3"))
# Size: Rename this to Carapace_Size. Ordinarily Carapace_Width would be used,
# but we have both Chionoecetes (width is measured) and king crabs (length is measured)
full.plate.dat <- rename(full.plate.dat, Carapace_Size = Size)
# Check min and max values to ensure no codes (such as -9 for unknown) are present
min(full.plate.dat$Carapace_Size, na.rm = TRUE)
max(full.plate.dat$Carapace_Size, na.rm = TRUE)
# Chela: Rename this to Chela_Height
full.plate.dat <- rename(full.plate.dat, Chela_Height = Chela)
# Again, check min and max values to ensure no codes are present
min(full.plate.dat$Chela_Height, na.rm = TRUE)
max(full.plate.dat$Chela_Height, na.rm = TRUE)
# We have some values of 0, which is impossible. Change these to NA
full.plate.dat <- full.plate.dat %>%
mutate(Chela_Height = na_if(Chela_Height, "0"))
# Shell condition: Check just for consistent code use. Should be all 0-5, with nearly all 2-4
table(full.plate.dat$Shell_Condition, useNA = "ifany")
# Change the 9 to a NA. Likely entered as a -9, which means NA
full.plate.dat <- full.plate.dat %>%
mutate(Shell_Condition = na_if(Shell_Condition, "9"))
# Clutch: Check code use
table(full.plate.dat$Clutch, useNA = "ifany")
# Random: Check
table(full.plate.dat$Random, useNA = "ifany")
# BODYID: Check
table(full.plate.dat$BODYID, useNA = "ifany")
# After consulting the Access key, ULC = unspecified location. We'll change these to NAs
full.plate.dat <- full.plate.dat %>%
mutate(BODYID = na_if(BODYID, "ULC"))
# VISUAL: Check
table(full.plate.dat$VISUAL, useNA = "ifany")
# Those "Yes" and "No" values are from the 2015 SMI survey. "Yes" = visual BCS
# The usual code for visual BCS is 387
full.plate.dat$VISUAL <- recode(full.plate.dat$VISUAL, "Yes" = "387")
full.plate.dat <- full.plate.dat %>%
mutate(VISUAL = na_if(VISUAL, "No"))
# Year: Will certainly leave, just want to check distribution of samples by year
table(full.plate.dat$Year, useNA = "ifany")
# HISTO_result: Check
table(full.plate.dat$HISTO_result, useNA = "ifany")
# All values are 7777 (no result) or 9999 (no histo for sample). Remove column
full.plate.dat <- select(full.plate.dat, -HISTO_result)
# SMEAR_result: Check
table(full.plate.dat$SMEAR_result, useNA = "ifany")
# According to Access key, 0 = negative, 1 = positive, 3 = unknown,
# 4 = can't read slide, 8 = slide missing, 7777 = no result, 9999 = no smear for sample
# Change 3, 4, 8, 7777, and 9999 to NA
full.plate.dat <- full.plate.dat %>%
mutate(SMEAR_result = na_if(SMEAR_result, "3"))
full.plate.dat <- full.plate.dat %>%
mutate(SMEAR_result = na_if(SMEAR_result, "4"))
full.plate.dat <- full.plate.dat %>%
mutate(SMEAR_result = na_if(SMEAR_result, "8"))
full.plate.dat <- full.plate.dat %>%
mutate(SMEAR_result = na_if(SMEAR_result, "7777"))
full.plate.dat <- full.plate.dat %>%
mutate(SMEAR_result = na_if(SMEAR_result, "9999"))
# T_Rating: Check
table(full.plate.dat$T_Rating, useNA = "ifany")
# BCS_PCR_results: check
table(full.plate.dat$BCS_PCR_results, useNA = "ifany")
# We'll keep 0, 1, and 3 (negative, positive, inconclusive), but change 7777 (no result) to NA
full.plate.dat <- full.plate.dat %>%
mutate(BCS_PCR_results = na_if(BCS_PCR_results, "7777"))
# Specific_Location and General Location: check simultaneously
table(full.plate.dat$Specific_Location, full.plate.dat$General_Location, useNA = "ifany")
# Collected_By: check
table(full.plate.dat$Collected_By, useNA = "ifany")
# We'll remove this column, since this provides minimal info
# In fact, it may be more confusing than helpful, as ADFG people can be on NOAA surveys and vice-versa
full.plate.dat <- select(full.plate.dat, -Collected_By)
# Cruise: Check only for error codes such as 9999
table(full.plate.dat$Cruise, useNA = "ifany")
# Cruise = 0 is from Greenland collections, Cruise = NA is from the 2015 SMI survey collections.
# Change Cruise = 0 to NA
full.plate.dat <- full.plate.dat %>%
mutate(Cruise = na_if(Cruise, "0"))
# Vessel: Check only for error codes such as 9999
table(full.plate.dat$Vessel, useNA = "ifany")
# Change 999 values (Shore and/or Dock) to NA
full.plate.dat <- full.plate.dat %>%
mutate(Vessel = na_if(Vessel, "999"))
# Haul: Check only for error codes
table(full.plate.dat$Haul, useNA = "ifany")
# Change Haul 0 codes to NAs
full.plate.dat <- full.plate.dat %>%
mutate(Haul = na_if(Haul, "0"))
# StationID: Check only for error codes
table(full.plate.dat$StationID, useNA = "ifany")
# Stratum: Check only for error codes
table(full.plate.dat$Stratum, useNA = "ifany")
# Change 999 to NA
full.plate.dat <- full.plate.dat %>%
mutate(Stratum = na_if(Stratum, "999"))
# LME: Check
table(full.plate.dat$LME, useNA = "ifany")
# According to the Access key, this is just a more general version of the General_Location column
# Check General_Location fits LME
table(full.plate.dat$LME, full.plate.dat$General_Location, useNA = "ifany")
# We have only 1 General_Location category with multiple LME values
# BS (Bering Sea) is present in both Bering Sea/Slope and NE Arctic/Chukchi Sea
# Add table of specific location
table(full.plate.dat$LME, full.plate.dat$Specific_Location, useNA = "ifany")
# Looks like we have 708 crabs with LME = NE Arctic/Chukchi Sea and all have Specific_Location = NA
# Change those crabs to Specific_Location = CS (Chukchi Sea/Arctic Ocean
full.plate.dat[full.plate.dat$LME == 54 & !is.na (full.plate.dat$LME), ]$Specific_Location <- "CS"
# Since all data is now captured in General_Location and Specific_Location tables, can remove
full.plate.dat <- select(full.plate.dat, -LME)
# Bering_Sea_Regions: Check
table(full.plate.dat$Bering_Sea_Regions, useNA = "ifany")
# Haul_Date
sum(is.na(full.plate.dat$Date))
sum(is.na(full.plate.dat$Haul_Date))
nrow(full.plate.dat[is.na(full.plate.dat$Haul_Date) & is.na(full.plate.dat$Date), ])
# We have 1077 NAs in Haul_Date, and only 40 in Date. All 40 of those also have NAs for Haul_Date
# Therefore, remove the Haul_Date column
full.plate.dat <- select(full.plate.dat, -Haul_Date)
# Latitude: Expect a large number of possible values
# Check max and min
max(full.plate.dat$Latitude, na.rm = TRUE)
min(full.plate.dat$Latitude, na.rm = TRUE)
# Longitude: Expect a large number of possible values
# Check max and min
max(full.plate.dat$Longitude, na.rm = TRUE)
min(full.plate.dat$Longitude, na.rm = TRUE)
# Depth: Expect a large number of possible values
# Check max and min
max(full.plate.dat$Depth, na.rm = TRUE)
min(full.plate.dat$Depth, na.rm = TRUE)
# Bottom_Type: Check
table(full.plate.dat$Bottom_Type, useNA = "ifany")
# Bottom_Temp: Expect a large number of possible values
# Check max and min
max(full.plate.dat$Bottom_Temp, na.rm = TRUE)
min(full.plate.dat$Bottom_Temp, na.rm = TRUE)
# Surface_Temp: Expect a large number of possible values
# Check max and min
max(full.plate.dat$Surface_Temp, na.rm = TRUE)
min(full.plate.dat$Surface_Temp, na.rm = TRUE)
# Category1 - Category5_decapods:
table(full.plate.dat$Category1)
table(full.plate.dat$Category2)
table(full.plate.dat$Category3)
table(full.plate.dat$Category4)
table(full.plate.dat$Category5_decapods, full.plate.dat$Species_Name)
# We'll directly remove Categories 1-4, as 1-3 are all identical, and separating anomura from brachyura doesn't require a column
full.plate.dat <- select(full.plate.dat, -c(Category1, Category2, Category3, Category4))
# However, we'll rename Category5_decapods, as well as the values within it, as it mostly captures Family-level phylogeny, and is thus useful
# In two cases, we'll use Superfamily-level names. They are as follows:
#    - Majoidae: Includes the Majidae family (Chionoecetes spp.) and the Oregoniidae family (Hyas spp.)
#    - Lithodoidae: Includes the Lithodidae family (Lithodes and Paralithodes spp.) and the Hapalogastridae family (Placetron wosnessenskii)
# There are only 2 crabs labeled "other brachyurans" - E. isenbeckii, and T. cheiroganus. These are both members of the Cheiragonidae family,
# so we'll relabel "other brachyurans" as "Cheiragonidae"
full.plate.dat <- rename(full.plate.dat, Family = Category5_decapods)
full.plate.dat$Family <- recode(full.plate.dat$Family, cancrids = "Cancridae",
hermits = "Paguridae",
lithodids = "Lithodoidea",
majids = "Majoidea",
"other brachyurans" = "Cheiragonidae",
pandalids = "Pandalidae")
# To ensure this column is fully complete, check if we have any NA values
table(full.plate.dat$Family, full.plate.dat$Species_Name, useNA = "ifany")
# We do - 3-4000 in C. bairdi and C. opilio, and 1 for T. cheiragonus
full.plate.dat[full.plate.dat$Species_Name == "Chionoecetes opilio" & is.na(full.plate.dat$Family), ]$Family <- "Majoidea"
full.plate.dat[full.plate.dat$Species_Name == "Chionoecetes bairdi" & is.na(full.plate.dat$Family), ]$Family <- "Majoidea"
full.plate.dat[full.plate.dat$Species_Name == "Telmessus cheiragonus" & is.na(full.plate.dat$Family), ]$Family <- "Cheiragonidae"
# Check we did everything right
table(full.plate.dat$Family, full.plate.dat$Species_Name, useNA = "ifany")
# Plate: Check only for error codes
table(full.plate.dat$Plate, useNA = "ifany")
# Egg_Color: Check
table(full.plate.dat$Egg_Color, useNA = "ifany")
# Egg_Cond; Check
table(full.plate.dat$Egg_Cond, useNA = "ifany")
# DNA_Well_No: Check
table(full.plate.dat$DNA_Well_No)
# Rename this, it's a bit confusing
full.plate.dat <- full.plate.dat %>%
rename(Plate_Location = DNA_Well_No)
# Avg_salinity_PSU: Expect a large number of possible values
# Check max and min
max(full.plate.dat$Avg_salinity_PSU, na.rm = TRUE)
min(full.plate.dat$Avg_salinity_PSU, na.rm = TRUE)
# SPN: Check only for error codes
table(full.plate.dat$SPN)
# Removed_Dead: We don't really care about it and it only applies to a few crab, remove
full.plate.dat <- select(full.plate.dat, -Removed_Dead)
# Well_Num: Expect a large number of possible values
table(full.plate.dat$Well_Num, useNA = "ifany")
# Write plate data to file
write.csv(full.plate.dat, file = "../output/jensen_data/cleaned_data/relevant_sample_data.csv", row.names = FALSE)
# Write plate data to file
write.csv(full.plate.dat, file = "../output/jensen_data/cleaned_data/relevant_sample_data.csv", row.names = FALSE)
knitr::opts_chunk$set(echo = TRUE)
crabdat <- read.csv("../output/jensen_data/cleaned_data/relevant_sample_data.csv")
View(crabdat)
View(crabdat)
knitr::opts_chunk$set(echo = FALSE)
crabdat <- read.csv("../output/jensen_data/cleaned_data/relevant_sample_data.csv")
View(crabdat)
table(crabdat$General_Location)
ggplot(data = crabdat, aes(x = General_Location)) +
geom_bar()
library(tidyverse)
ggplot(data = crabdat, aes(x = General_Location)) +
geom_bar()
ggplot(data = crabdat, aes(x = General_Location)) +
geom_bar() +
theme_minimal()
ggplot(data = crabdat, aes(x = General_Location)) +
geom_bar() +
theme_classic()
ggplot(data = crabdat, aes(x = General_Location)) +
geom_bar() +
theme_
ggplot(data = crabdat, aes(x = General_Location)) +
geom_bar() +
theme_minimal()
ggplot(data = crabdat, aes(x = General_Location)) +
geom_bar(fill = "steelblue", color = "steelblue") +
theme_minimal()
crabdat %>%
ggplot(aes(x = General_Location)) +
geom_bar(fill = "steelblue", color = "steelblue") +
theme_minimal()
crabdat %>%
ggplot(aes(x = General_Location)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(title = "Location of Samples",
x = "Area of Collection",
y = "Number of Samples") +
theme_minimal()
crabdat %>%
ggplot(aes(x = General_Location)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(title = "Location of Samples",
x = "Area of Collection",
y = "Number of Samples") +
theme(plot.title = element_text(hjust = 0.5))
crabdat %>%
ggplot(aes(x = General_Location)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(title = "Location of Samples",
x = "Area of Collection",
y = "Number of Samples") +
theme(plot.title = element_text(hjust = 0.5)) +
theme_minimal()
crabdat %>%
ggplot(aes(x = General_Location)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(title = "Location of Samples",
x = "Area of Collection",
y = "Number of Samples") +
theme(plot.title = element_text(hjust = 0.5))
crabdat %>%
ggplot(aes(x = General_Location)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(title = "Location of Sample Collection",
x = "General Area",
y = "Number of Samples") +
theme(plot.title = element_text(hjust = 0.5)) +
theme_minimal()
crabdat %>%
ggplot(aes(x = General_Location)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(title = "Location of Sample Collection",
x = "General Area",
y = "Number of Samples") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
crabdat %>%
ggplot(aes(x = General_Location)) +
geom_bar(fill = "steelblue", color = "steelblue") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
crabdat %>%
ggplot(aes(x = General_Location)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(title = "Location of Sample Collection",
x = "General Area",
y = "Number of Samples") +
theme_minimal()
crabdat %>%
ggplot(aes(x = General_Location)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(title = "Location of Sample Collection",
x = "General Area",
y = "Number of Samples") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
View(crabdat)
crabdat %>%
ggplot(aes(x = Species)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(x = "General Area",
y = "Number of Samples") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
View(crabdat)
crabdat %>%
ggplot(aes(x = Species_Name)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(x = "General Area",
y = "Number of Samples") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
table(crabdat$Species_Name)
?mutate
crabdat["Chionoecetes" %in% crabdat$Species_Name, ]
crabdat[crabdat$Species_Name == "Chionoecetes bairdi" | "Chionoecetes opilio", ]
crabdat[crabdat$Species_Name == "Chionoecetes bairdi", ]
crabdat[crabdat$Species_Name == "Chionoecetes bairdi" | crabdat$Species_Name == "Chionoecetes opilio", ]
table(crabdat$Species_Name)
filt_crabdat <- crabdat[crabdat$Species_Name == "Chionoecetes bairdi" | crabdat$Species_Name == "Chionoecetes opilio", ]
filt_crabdat <- crabdat[crabdat$Species_Name == "Chionoecetes bairdi" | crabdat$Species_Name == "Chionoecetes opilio", ]
filt_crabdat %>%
ggplot(aes(x = Species_Name)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(x = "General Area",
y = "Number of Samples") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
filt_crabdat <- crabdat
filt_crabdat[filt_crabdat$Species_Name != "Chionoecetes bairdi" | filt_crabdat$Species_Name != "Chionoecetes opilio", ]$Species_Name <- "Other"
table(filt_crabdat$Species_Name)
filt_crabdat <- crabdat
filt_crabdat[-filt_crabdat$Species_Name == "Chionoecetes bairdi" | filt_crabdat$Species_Name == "Chionoecetes opilio", ]$Species_Name <- "Other"
filt_crabdat["Chionoecetes" %in% filt_crabdat$Species_Name, ]
View(crabdat)
filt_crabdat <- crabdat
filt_crabdat[filt_crabdat$Family != "Majoidea", ]$Species_Name <- "Other"
table(filt_crabdat$Species_Name)
filt_crabdat[filt_crabdat$Species_Name == "Hyas*", ]$Species_Name
filt_crabdat[filt_crabdat$Species_Name == "Hyas sp.", ]$Species_Name
filt_crabdat[filt_crabdat$Species_Name == "Hyas *", ]
filt_crabdat[filt_crabdat$Species_Name == "Hyas ?", ]
filt_crabdat[filt_crabdat$Species_Name == "Hyas lyratus", ]$Species_Name <- "Other"
table(filt_crabdat$Species_Name)
filt_crabdat[filt_crabdat$Species_Name == "Hyas sp.", ]$Species_Name <- "Other"
filt_crabdat[filt_crabdat$Species_Name == "Hyas coarctatus", ]$Species_Name <- "Other"
table(filt_crabdat$Species_Name)
filt_crabdat[filt_crabdat$Species_Name == "Chionoecetes hybrid", ]$Species_Name <- "Other"
table(filt_crabdat$Species_Name)
crabdat %>%
ggplot(aes(x = Species_Name)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(x = "General Area",
y = "Number of Samples") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
filt_crabdat %>%
ggplot(aes(x = Species_Name)) +
geom_bar(fill = "steelblue", color = "steelblue") +
labs(x = "General Area",
y = "Number of Samples") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
table(crabdat$Species_Name)
filt_crabdat <- crabdat
