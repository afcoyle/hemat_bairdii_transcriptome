go_descriptions <- rename(go_descriptions, "Accession_ID" = "Entry")
# Drop the Transcript ID column from our immune genes table
gene_names <- select(genes_tab, -Transcript_ID)
gene_names <- unique(gene_names)
# Merge gene descriptions and immune genes by Accession ID
gene_descriptions <- left_join(gene_names, go_descriptions, by = "Accession_ID")
# Remove Status column, as it's identical for all
gene_descriptions <- select(gene_descriptions, -Status)
# Remove all columns after the first 6 (all latter ones are specific GO terms)
gene_descriptions <- gene_descriptions[, 1:6]
# Write to file
write.csv(gene_descriptions, file = paste0("../output/all_genes/", transcriptomes[i], "/all_gene_names.csv"),
row.names = FALSE)
}
# Write table to file
write.table(genes_tab, file = paste0("../output/all_genes/", transcriptomes[i], "/transcript_accession_IDs/all_indiv_libraries.txt"),
row.names = FALSE,
sep = "\t")
}
knitr::opts_chunk$set(echo = TRUE)
# Add all required libraries that are installed with install.packages() here
list.of.packages <- c("tidyverse", "plotly")
# Add all libraries that are installed using BiocManager here
bioconductor.packages <- c("apeglm", "DESeq2", "vsn")
# Install BiocManager if needed
if(!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
new.bioc.packages <- bioconductor.packages[!(bioconductor.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
if(length(new.bioc.packages)) BiocManager::install(new.bioc.packages)
# Load all required libraries
all.packages <- c(list.of.packages, bioconductor.packages)
lapply(all.packages, FUN = function(X) {
do.call("require", list(X))
})
# Functions are defined in hematodinium_analysis_functions.R
source("hematodinium_analysis_functions.R")
knitr::opts_chunk$set(echo = TRUE)
exp_design <- data.frame(temp = factor(c("Low", "Amb", "Elev")),
day = factor(c(0, 2, 17)))
exp_design
knitr::opts_chunk$set(echo = TRUE)
# Add all required libraries here
list.of.packages <- "tidyverse"
# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
# Load all required libraries
lapply(list.of.packages, FUN = function(X) {
do.call("require", list(X))
})
# Functions are defined in hematodinium_analysis_functions.R
source("hematodinium_analysis_functions.R")
# Ambient Day 0 vs. Ambient Day 2, indiv. libraries only
geneIDs_pvals(input_file = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv/AllGenes_wcols.txt",
blast_file = "../output/BLASTs/uniprot_swissprot/hemat1.6_blastxres.tab",
output_file = "../scripts/36_running_GO-MWU/hemat1.6_amb0_vs_amb2_indiv_pvals.csv")
getwd()
exp_design <- data.frame(temp = factor(c("amb", "amb", "amb",
"amb", "amb", "amb")),
day = factor(c(0, 0, 0,
2, 2, 2)))
deseq_analysis(kallisto_path = "../output/kallisto_matrices/hemat_transcriptomev1.6/amb2_vs_elev2_indiv/kallisto.isoform.counts.matrix",
experiment_table = exp_design,
output_path = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv",
variable = "temp")
exp_design <- data.frame(day = factor(c(0, 0, 0,
2, 2, 2)))
deseq_analysis(kallisto_path = "../output/kallisto_matrices/hemat_transcriptomev1.6/amb2_vs_elev2_indiv/kallisto.isoform.counts.matrix",
experiment_table = exp_design,
output_path = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv",
variable = "temp")
exp_design <- data.frame(temp = factor(c("amb", "amb", "amb",
"amb", "amb", "amb")),
day = factor(c(0, 0, 0,
2, 2, 2)))
deseq_analysis(kallisto_path = "../output/kallisto_matrices/hemat_transcriptomev1.6/amb2_vs_elev2_indiv/kallisto.isoform.counts.matrix",
experiment_table = exp_design,
output_path = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv",
variable = "temp")
exp_design <- data.frame(temp = ~ 1,
day = factor(c(0, 0, 0,
2, 2, 2)))
exp_design <- data.frame(day = factor(c(0, 0, 0,
2, 2, 2)),
temp = factor(c("amb", "amb", "amb",
"amb", "amb", "amb")))
deseq_analysis(kallisto_path = "../output/kallisto_matrices/hemat_transcriptomev1.6/amb2_vs_elev2_indiv/kallisto.isoform.counts.matrix",
experiment_table = exp_design,
output_path = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv",
variable = "temp")
exp_design <- data.frame(day = factor(c(0, 0, 0,
2, 2, 2)),
temp = factor(c("amb", "amb", "amb",
"amb", "amb", "amb")))
deseq_analysis(kallisto_path = "../output/kallisto_matrices/hemat_transcriptomev1.6/amb2_vs_elev2_indiv/kallisto.isoform.counts.matrix",
experiment_table = exp_design,
output_path = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv",
variable = "day")
knitr::opts_chunk$set(echo = TRUE)
# Ambient Day 0 vs. Ambient Day 2. Individual libraries
uniprot_to_GO(accession_path = "../output/accession_n_GOids/hemat_transcriptomev1.6/allgenes_IDs/amb0_vs_amb2_indiv_All_GeneIDs.txt",
swissprot_path = "../data/all_uniprot_info_inc_GOterms.tab",
output_path = "../output/accession_n_GOids/hemat_transcriptomev1.6/allgenes_IDs/amb0_vs_amb2_indiv_All_GOIDs.txt")
# Ambient Day 0 vs. Ambient Day 2. Individual libraries
uniprot_to_GO(accession_path = "../output/accession_n_GOids/hemat_transcriptomev1.6/allgenes_IDs/amb0_vs_amb2_indiv/All_GeneIDs.txt",
swissprot_path = "../data/all_uniprot_info_inc_GOterms.tab",
output_path = "../output/accession_n_GOids/hemat_transcriptomev1.6/allgenes_IDs/amb0_vs_amb2_indiv_All_GOIDs.txt")
# Ambient Day 0 vs. Ambient Day 2
transcripts_to_geneIDs(deseq_filepath = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv/DEGlist_wcols.txt",
blast_filepath =  "../output/BLASTs/uniprot_swissprot/hemat1.6_blastxres.tab",
output_path = "../output/accession_n_GOids/hemat_transcriptomev1.6/DEG_IDs/amb0_vs_amb2_indiv_DEG_IDs.txt")
# Ambient Day 0 vs. Ambient Day 2
transcripts_to_geneIDs(deseq_filepath = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv/AllGenes_wcols.txt",
blast_filepath =  "../output/BLASTs/uniprot_swissprot/hemat1.6_blastxres.tab",
output_path = "../output/accession_n_GOids/hemat_transcriptomev1.6/allgenes_IDs/amb0_vs_amb2_indiv_All_GeneIDs.txt")
# Ambient Day 0 vs. Ambient Day 2. Individual libraries
uniprot_to_GO(accession_path = "../output/accession_n_GOids/hemat_transcriptomev1.6/allgenes_IDs/amb0_vs_amb2_indiv_All_GeneIDs.txt",
swissprot_path = "../data/all_uniprot_info_inc_GOterms.tab",
output_path = "../output/accession_n_GOids/hemat_transcriptomev1.6/allgenes_IDs/amb0_vs_amb2_indiv_All_GOIDs.txt")
# Ambient Day 0 vs. Ambient Day 2, indiv. libraries only
geneIDs_pvals(input_file = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv/AllGenes_wcols.txt",
blast_file = "../output/BLASTs/uniprot_swissprot/hemat1.6_blastxres.tab",
output_file = "../scripts/36_running_GO-MWU/hemat1.6_amb0_vs_amb2_indiv_pvals.csv")
# Add all required libraries here
list.of.packages <- "tidyverse"
# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
# Load all required libraries
lapply(list.of.packages, FUN = function(X) {
do.call("require", list(X))
})
# Functions are defined in hematodinium_analysis_functions.R
source("hematodinium_analysis_functions.R")
# Ambient Day 0 vs. Ambient Day 2, indiv. libraries only
geneIDs_pvals(input_file = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv/AllGenes_wcols.txt",
blast_file = "../output/BLASTs/uniprot_swissprot/hemat1.6_blastxres.tab",
output_file = "../scripts/36_running_GO-MWU/hemat1.6_amb0_vs_amb2_indiv_pvals.csv")
# Ambient Day 0 vs. Ambient Day 2, indiv. libraries only
geneIDs_pvals(input_file = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv/AllGenes_wcols.txt",
blast_file = "../output/BLASTs/uniprot_swissprot/hemat1.6_blastxres.tab",
output_file = "../scripts/3_6_running_GO-MWU/hemat1.6_amb0_vs_amb2_indiv_pvals.csv")
# Ambient Day 2 vs. Elevated Day 2, indiv. libraries only
geneIDs_pvals(input_file = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb2_vs_elev2_indiv/AllGenes_wcols.txt",
blast_file = "../output/BLASTs/uniprot_swissprot/hemat1.6_blastxres.tab",
output_file = "../scripts/3_6_running_GO-MWU/hemat1.6_amb2_vs_elev2_indiv_pvals.csv")
input_file = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv/AllGenes_wcols.txt"
blast_file = "../output/BLASTs/uniprot_swissprot/hemat1.6_blastxres.tab"
output_file = "../scripts/3_6_running_GO-MWU/hemat1.6_amb0_vs_amb2_indiv_pvals.csv"
# Import gene list
transcript_data <- read.table(input_file,
header = TRUE, sep = "\t")
# Transcript IDs are rownames - move them into first column
transcript_data <- tibble::rownames_to_column(transcript_data,
"Transcript_ID")
# Read BLAST data into R
blast_data <- read.table(blast_file, header = FALSE,
sep = "\t")
# Columns have no names - add names for first two columns
colnames(blast_data)[1:2] <- c("Transcript_ID", "Gene_ID")
View(blast_data)
# Turn the first two columns of BLAST data into a Transcript ID/Gene ID key
blastkey <- blast_data %>%
select(Transcript_ID, Gene_ID)
# Add Gene ID column to transcript data, using Transcript ID column to match
transcript_data <- left_join(transcript_data, blastkey, by = "Transcript_ID")
# Select only the Transcript ID, p-value, and Gene ID columns
transcript_key <- transcript_data[,c("Transcript_ID", "pvalue", "Gene_ID")]
# If pipes in accession ID column, separate to get accession ID,
# remove all columns except transcript ID, accession ID, and p-value
# and remove all rows with an NA accession ID
gene_ids <- dplyr::pull(transcript_key, Gene_ID)
if(any(grepl("|", gene_ids, fixed = TRUE))){
transcript_key <- separate(data = transcript_key, col = Gene_ID,
into = c("sp", "Accession_ID", "species"),
sep = "\\|")
transcript_key <- transcript_key[!is.na(transcript_key$Accession_ID), c(4, 2)]
} else {
# If no pipes in accession ID column, remove all rows with an NA accession ID,
# remove the first column (transcript ID), and reorder the 2nd and 3rd (should be accession ID, then p-value)
transcript_key <- transcript_key %>%
rename(Accession_ID = Gene_ID)
transcript_key <- transcript_key[!is.na(transcript_key$Accession_ID), c(3, 2)]
}
transcript_key <- separate(data = transcript_key, col = Gene_ID,
into = c("sp", "Accession_ID", "species"),
sep = "\\|")
?rename
# Import gene list
transcript_data <- read.table(input_file,
header = TRUE, sep = "\t")
# Transcript IDs are rownames - move them into first column
transcript_data <- tibble::rownames_to_column(transcript_data,
"Transcript_ID")
# Read BLAST data into R
blast_data <- read.table(blast_file, header = FALSE,
sep = "\t")
# Columns have no names - add names for first two columns
colnames(blast_data)[1:2] <- c("Transcript_ID", "Gene_ID")
# Turn the first two columns of BLAST data into a Transcript ID/Gene ID key
blastkey <- blast_data %>%
select(Transcript_ID, Gene_ID)
# Add Gene ID column to transcript data, using Transcript ID column to match
transcript_data <- left_join(transcript_data, blastkey, by = "Transcript_ID")
# Select only the Transcript ID, p-value, and Gene ID columns
transcript_key <- transcript_data[,c("Transcript_ID", "pvalue", "Gene_ID")]
# If pipes in accession ID column, separate to get accession ID,
# remove all columns except transcript ID, accession ID, and p-value
# and remove all rows with an NA accession ID
gene_ids <- dplyr::pull(transcript_key, Gene_ID)
View(transcript_key)
# If no pipes in accession ID column, remove all rows with an NA accession ID,
# remove the first column (transcript ID), and reorder the 2nd and 3rd (should be accession ID, then p-value)
transcript_key <- transcript_key %>%
rename(Accession_ID = Gene_ID)
View(transcript_key)
# If no pipes in accession ID column, remove all rows with an NA accession ID,
# remove the first column (transcript ID), and reorder the 2nd and 3rd (should be accession ID, then p-value)
test <- transcript_key %>%
rename(Accession_ID = pvalue)
# If no pipes in accession ID column, remove all rows with an NA accession ID,
# remove the first column (transcript ID), and reorder the 2nd and 3rd (should be accession ID, then p-value)
test <- rename(transcript_key, Accession_ID = pvalue)
# If no pipes in accession ID column, remove all rows with an NA accession ID,
# remove the first column (transcript ID), and reorder the 2nd and 3rd (should be accession ID, then p-value)
test <- rename(transcript_key, pvalue = test)
# If no pipes in accession ID column, remove all rows with an NA accession ID,
# remove the first column (transcript ID), and reorder the 2nd and 3rd (should be accession ID, then p-value)
test <- rename(transcript_key, "Accession_ID" = "pvalue")
# If no pipes in accession ID column, remove all rows with an NA accession ID,
# remove the first column (transcript ID), and reorder the 2nd and 3rd (should be accession ID, then p-value)
test <- transcript_key %>%
rename(transcript_key, "Accession_ID" = "pvalue")
# If no pipes in accession ID column, remove all rows with an NA accession ID,
# remove the first column (transcript ID), and reorder the 2nd and 3rd (should be accession ID, then p-value)
test <- transcript_key %>%
rename(transcript_key, "Accession_ID" = "Gene_ID")
# If no pipes in accession ID column, remove all rows with an NA accession ID,
# remove the first column (transcript ID), and reorder the 2nd and 3rd (should be accession ID, then p-value)
test <- transcript_key %>%
rename(transcript_key, "Accession_ID" = "Gene_ID")
# If no pipes in accession ID column, remove all rows with an NA accession ID,
# remove the first column (transcript ID), and reorder the 2nd and 3rd (should be accession ID, then p-value)
test <- transcript_key %>%
rename("Accession_ID" = "Gene_ID")
# If no pipes in accession ID column, remove all rows with an NA accession ID,
# remove the first column (transcript ID), and reorder the 2nd and 3rd (should be accession ID, then p-value)
test <- transcript_key %>%
rename("Gene_ID" = "Accession_ID")
View(test)
# Add all required libraries here
list.of.packages <- "tidyverse"
# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
# Load all required libraries
lapply(list.of.packages, FUN = function(X) {
do.call("require", list(X))
})
# Functions are defined in hematodinium_analysis_functions.R
source("hematodinium_analysis_functions.R")
# Ambient Day 0 vs. Ambient Day 2, indiv. libraries only
geneIDs_pvals(input_file = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv/AllGenes_wcols.txt",
blast_file = "../output/BLASTs/uniprot_swissprot/hemat1.6_blastxres.tab",
output_file = "../scripts/3_6_running_GO-MWU/hemat1.6_amb0_vs_amb2_indiv_pvals.csv")
library(ape)
# I know, I know - suboptimal to have setwd().
# I assume that all scripts start from within your scripts directory,
# so this just indicates that you need to move to the same subdirectory
# as all other GO-MWU files - both data files and analysis files.
# GO-MWU doesn't cooperate otherwise.
setwd("36_running_GO-MWU")
getwd()
# I know, I know - suboptimal to have setwd().
# I assume that all scripts start from within your scripts directory,
# so this just indicates that you need to move to the same subdirectory
# as all other GO-MWU files - both data files and analysis files.
# GO-MWU doesn't cooperate otherwise.
setwd("36_running_GO-MWU")
# I know, I know - suboptimal to have setwd().
# I assume that all scripts start from within your scripts directory,
# so this just indicates that you need to move to the same subdirectory
# as all other GO-MWU files - both data files and analysis files.
# GO-MWU doesn't cooperate otherwise.
setwd("3_6_running_GO-MWU")
# Edit these to match your data file names:
input="hemat1.6_amb0_vs_amb2_indiv_pvals.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="hemat1.6_amb2_vs_elev2_indiv_GOIDs_norepeats.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="C:/Users/acoyl/Documents/GradSchool/RobertsLab/Tools/perl/bin/perl.exe", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
windows()
windows()
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=0.05,  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
# text representation of results, with actual adjusted p-values
results[[1]]
pcut=1e-2 # adjusted pvalue cutoff for representative GO
hcut=0.9 # height at which cut the GO terms tree to get "independent groups".
# plotting the GO tree with the cut level (un-remark the next two lines to plot)
plot(results[[2]],cex=0.6)
abline(h=hcut,col="red")
# plotting the GO tree with the cut level (un-remark the next two lines to plot)
plot(results[[2]],cex=0.6)
for (ci in unique(ct)) {
message(ci)
rn=names(ct)[ct==ci]
obs=grep("obsolete",rn)
if(length(obs)>0) { rn=rn[-obs] }
if (length(rn)==0) {next}
rr=results[[1]][rn,]
bestrr=rr[which(rr$pval==min(rr$pval)),]
best=1
if(nrow(bestrr)>1) {
nns=sub(" .+","",row.names(bestrr))
fr=c()
for (i in 1:length(nns)) { fr=c(fr,eval(parse(text=nns[i]))) }
best=which(fr==max(fr))
}
if (bestrr$pval[best]<=pcut) { annots=c(annots,sub("\\d+\\/\\d+ ","",row.names(bestrr)[best]))}
}
mwus=read.table(paste("MWU",goDivision,input,sep="_"),header=T)
bestGOs=mwus[mwus$name %in% annots,]
# plotting the GO tree with the cut level (un-remark the next two lines to plot)
plot(results[[2]],cex=0.6)
abline(h=hcut,col="red")
# cutting
ct=cutree(results[[2]],h=hcut)
annots=c();ci=1
for (ci in unique(ct)) {
message(ci)
rn=names(ct)[ct==ci]
obs=grep("obsolete",rn)
if(length(obs)>0) { rn=rn[-obs] }
if (length(rn)==0) {next}
rr=results[[1]][rn,]
bestrr=rr[which(rr$pval==min(rr$pval)),]
best=1
if(nrow(bestrr)>1) {
nns=sub(" .+","",row.names(bestrr))
fr=c()
for (i in 1:length(nns)) { fr=c(fr,eval(parse(text=nns[i]))) }
best=which(fr==max(fr))
}
if (bestrr$pval[best]<=pcut) { annots=c(annots,sub("\\d+\\/\\d+ ","",row.names(bestrr)[best]))}
}
mwus=read.table(paste("MWU",goDivision,input,sep="_"),header=T)
bestGOs=mwus[mwus$name %in% annots,]
bestGOs
windows()
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=0.05,  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
# Add all required libraries that are installed with install.packages() here
list.of.packages <- c("tidyverse", "plotly")
# Add all libraries that are installed using BiocManager here
bioconductor.packages <- c("apeglm", "DESeq2", "vsn")
# Install BiocManager if needed
if(!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
# Get names of all required packages that aren't installed
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[, "Package"])]
new.bioc.packages <- bioconductor.packages[!(bioconductor.packages %in% installed.packages()[, "Package"])]
# Install all new packages
if(length(new.packages)) install.packages(new.packages)
if(length(new.bioc.packages)) BiocManager::install(new.bioc.packages)
# Load all required libraries
all.packages <- c(list.of.packages, bioconductor.packages)
lapply(all.packages, FUN = function(X) {
do.call("require", list(X))
})
# Functions are defined in hematodinium_analysis_functions.R
source("hematodinium_analysis_functions.R")
exp_design <- data.frame(day = factor(c(0, 0, 0,
2, 2, 2)),
temp = factor(c("amb", "amb", "amb",
"amb", "amb", "amb")))
deseq_analysis(kallisto_path = "../output/kallisto_matrices/hemat_transcriptomev1.6/amb2_vs_elev2_indiv/kallisto.isoform.counts.matrix",
experiment_table = exp_design,
output_path = "../graphs/DESeq2_output/hemat_transcriptomev1.6/amb0_vs_amb2_indiv",
variable = "day")
exp_design <- data.frame(day = factor(c(0, 0, 0,
2, 2, 2)),
temp = factor(c("amb", "amb", "amb",
"amb", "amb", "amb")))
deseq_analysis(kallisto_path = "../output/kallisto_matrices/cbai_transcriptomev4.0/amb2_vs_elev2_indiv/kallisto.isoform.counts.matrix",
experiment_table = exp_design,
output_path = "../graphs/DESeq2_output/cbai_transcriptomev4.0/amb0_vs_amb2_indiv",
variable = "day")
knitr::opts_chunk$set(echo = TRUE)
# Ambient Day 0 vs. Ambient Day 2. Individual libraries
uniprot_to_GO(accession_path = "../output/accession_n_GOids/cbai_transcriptomev4.0/allgenes_IDs/amb0_vs_amb2_indiv_All_GeneIDs.txt",
swissprot_path = "../data/all_uniprot_info_inc_GOterms.tab",
output_path = "../output/accession_n_GOids/cbai_transcriptomev4.0/allgenes_IDs/amb0_vs_amb2_indiv_All_GOIDs.txt")
# Ambient Day 0 vs. Ambient Day 2
transcripts_to_geneIDs(deseq_filepath = "../graphs/DESeq2_output/cbai_transcriptomev4.0/amb0_vs_amb2_indiv/DEGlist_wcols.txt",
blast_filepath =  "../output/BLASTs/uniprot_swissprot/cbai4.0_blastxres.tab",
output_path = "../output/accession_n_GOids/cbai_transcriptomev4.0/DEG_IDs/amb0_vs_amb2_indiv_DEG_IDs.txt")
# Ambient Day 0 vs. Ambient Day 2
transcripts_to_geneIDs(deseq_filepath = "../graphs/DESeq2_output/cbai_transcriptomev4.0/amb0_vs_amb2_indiv/AllGenes_wcols.txt",
blast_filepath =  "../output/BLASTs/uniprot_swissprot/cbai4.0_blastxres.tab",
output_path = "../output/accession_n_GOids/cbai_transcriptomev4.0/allgenes_IDs/amb0_vs_amb2_indiv_All_GeneIDs.txt")
# Ambient Day 0 vs. Ambient Day 2. Individual libraries
uniprot_to_GO(accession_path = "../output/accession_n_GOids/cbai_transcriptomev4.0/allgenes_IDs/amb0_vs_amb2_indiv_All_GeneIDs.txt",
swissprot_path = "../data/all_uniprot_info_inc_GOterms.tab",
output_path = "../output/accession_n_GOids/cbai_transcriptomev4.0/allgenes_IDs/amb0_vs_amb2_indiv_All_GOIDs.txt")
knitr::opts_chunk$set(echo = TRUE)
# Ambient Day 0 vs. Ambient Day 2, indiv. libraries only
geneIDs_pvals(input_file = "../graphs/DESeq2_output/cbai_transcriptomev4.0/amb0_vs_amb2_indiv/AllGenes_wcols.txt",
blast_file = "../output/BLASTs/uniprot_swissprot/cbai4.0_blastxres.tab",
output_file = "../scripts/46_running_GO-MWU/cbai4.0_amb0_vs_amb2_indiv_pvals.csv")
getwd()
sedwd(../)
setwd("../")
getwd()
# Ambient Day 0 vs. Ambient Day 2, indiv. libraries only
geneIDs_pvals(input_file = "../graphs/DESeq2_output/cbai_transcriptomev4.0/amb0_vs_amb2_indiv/AllGenes_wcols.txt",
blast_file = "../output/BLASTs/uniprot_swissprot/cbai4.0_blastxres.tab",
output_file = "../scripts/46_running_GO-MWU/cbai4.0_amb0_vs_amb2_indiv_pvals.csv")
# Ambient Day 0 vs. Ambient Day 2, indiv. libraries only
geneIDs_pvals(input_file = "../graphs/DESeq2_output/cbai_transcriptomev4.0/amb0_vs_amb2_indiv/AllGenes_wcols.txt",
blast_file = "../output/BLASTs/uniprot_swissprot/cbai4.0_blastxres.tab",
output_file = "../scripts/4_6_running_GO-MWU/cbai4.0_amb0_vs_amb2_indiv_pvals.csv")
# I know, I know - suboptimal to have setwd().
# I assume that all scripts start from within your scripts directory,
# so this just indicates that you need to move to the same subdirectory
# as all other GO-MWU files - both data files and analysis files.
# GO-MWU doesn't cooperate otherwise.
setwd("4_6_running_GO-MWU")
library(ape)
# Edit these to match your data file names:
input="cbai4.0_amb0_vs_amb2_indiv_pvals.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="cbai4.0_amb0_vs_amb2_indiv_GOIDs_norepeats.txt" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="C:/Users/acoyl/Documents/GradSchool/RobertsLab/Tools/perl/bin/perl.exe", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead.
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module
)
grDevices::windows()
results=gomwuPlot(input,goAnnotations,goDivision,
absValue=0.05,  # genes with the measure value exceeding this will be counted as "good genes". This setting is for signed log-pvalues. Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
#	absValue=1, # un-remark this if you are using log2-fold changes
level1=0.1, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
level2=0.05, # FDR cutoff to print in regular (not italic) font.
level3=0.01, # FDR cutoff to print in large bold font.
txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
treeHeight=0.5, # height of the hierarchical clustering tree
#	colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
# text representation of results, with actual adjusted p-values
results[[1]]
pcut=1e-2 # adjusted pvalue cutoff for representative GO
hcut=0.9 # height at which cut the GO terms tree to get "independent groups".
# cutting
ct=cutree(results[[2]],h=hcut)
annots=c();ci=1
for (ci in unique(ct)) {
message(ci)
rn=names(ct)[ct==ci]
obs=grep("obsolete",rn)
if(length(obs)>0) { rn=rn[-obs] }
if (length(rn)==0) {next}
rr=results[[1]][rn,]
bestrr=rr[which(rr$pval==min(rr$pval)),]
best=1
if(nrow(bestrr)>1) {
nns=sub(" .+","",row.names(bestrr))
fr=c()
for (i in 1:length(nns)) { fr=c(fr,eval(parse(text=nns[i]))) }
best=which(fr==max(fr))
}
if (bestrr$pval[best]<=pcut) { annots=c(annots,sub("\\d+\\/\\d+ ","",row.names(bestrr)[best]))}
}
mwus=read.table(paste("MWU",goDivision,input,sep="_"),header=T)
bestGOs=mwus[mwus$name %in% annots,]
bestGOs
